<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode-17-电话号码的字母组合</title>
    <url>/2020/08/26/LeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String[][] dir = &#123;&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;, &#123;<span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>&#125;, &#123;<span class="string">&quot;g&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;i&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;j&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;l&quot;</span>&#125;, &#123;<span class="string">&quot;m&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;o&quot;</span>&#125;, &#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;s&quot;</span>&#125;, &#123;<span class="string">&quot;t&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;v&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;w&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dfs + 回溯</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> digits</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//传入初始参数</span></span><br><span class="line">        dfs(digits, <span class="number">0</span>, builder);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dfs 回溯时，先判断结束条件，即 判断是否满足条件，将临时数据保存到结果集合中</span></span><br><span class="line"><span class="comment">     * 递归前，先修改，再递归， 最后恢复</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> digits</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String digits, <span class="keyword">int</span> index, StringBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (builder.length() == digits.length()) &#123;</span><br><span class="line">            result.add(builder.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = (digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>) - <span class="number">2</span>;</span><br><span class="line">        String[] temp = dir[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.length; j++) &#123;</span><br><span class="line">            builder.append(temp[j]);</span><br><span class="line">            dfs(digits, index + <span class="number">1</span>, builder);</span><br><span class="line">            builder.deleteCharAt(builder.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>DFS</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-332-重新安排行程</title>
    <url>/2020/08/27/LeetCode-332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332. 重新安排行程"></a><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">332. 重新安排行程</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tags: 欧拉路径  dfs 回溯  图</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 什么是欧拉路径？欧拉路径就是一条能够不重不漏地经过图上的每一条边的路径，即小学奥数中的一笔画问题。而若这条路径的起点和终点相同，则将这条路径称为欧拉回路。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 如何判断一个图是否有欧拉路径呢？显然，与一笔画问题相同，一个图有欧拉路径需要以下几个条件：</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 首先，这是一个连通图</span></span><br><span class="line"><span class="comment"> * 若是无向图，则这个图的度数为奇数的点的个数必须是0或2；若是有向图，则要么所有点的入度和出度相等，要么有且只有两个点的入度分别比出度大1和少1</span></span><br><span class="line"><span class="comment"> * 上面这两个条件很好证明。查找欧拉路径前，必须先保证该图满足以上两个条件，否则直接判误即可。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 查找欧拉路径的算法有Fluery算法和Hierholzer算法。下面介绍一下Hierholzer算法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> l00511002</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-08-27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试代码</span></span><br><span class="line"><span class="comment">     * 特殊用例--[[&quot;JFK&quot;,&quot;KUL&quot;],[&quot;JFK&quot;,&quot;NRT&quot;],[&quot;NRT&quot;,&quot;JFK&quot;]]</span></span><br><span class="line"><span class="comment">     * String[][] array = &#123;&#123;&quot;MUC&quot;, &quot;LHR&quot;&#125;, &#123;&quot;JFK&quot;, &quot;MUC&quot;&#125;, &#123;&quot;SFO&quot;, &quot;SJC&quot;&#125;, &#123;&quot;LHR&quot;, &quot;SFO&quot;&#125;&#125;;</span></span><br><span class="line"><span class="comment">     * String[][] array = &#123;&#123;&quot;JFK&quot;, &quot;KUL&quot;&#125;, &#123;&quot;JFK&quot;, &quot;NRT&quot;&#125;, &#123;&quot;NRT&quot;, &quot;JFK&quot;&#125;&#125;;</span></span><br><span class="line"><span class="comment">     * String[][] array = &#123;&#123;&quot;JFK&quot;, &quot;SFO&quot;&#125;, &#123;&quot;JFK&quot;, &quot;ATL&quot;&#125;, &#123;&quot;SFO&quot;, &quot;ATL&quot;&#125;, &#123;&quot;ATL&quot;, &quot;JFK&quot;&#125;, &#123;&quot;ATL&quot;, &quot;SFO&quot;&#125;&#125;;</span></span><br><span class="line"><span class="comment">     * List&lt;List&lt;String&gt;&gt; tickets = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">     * for (int i = 0; i &lt; array.length; i++) &#123;</span></span><br><span class="line"><span class="comment">     * String[] strs = array[i];</span></span><br><span class="line"><span class="comment">     * List&lt;String&gt; strings = Arrays.asList(strs);</span></span><br><span class="line"><span class="comment">     * tickets.add(strings);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[][] array = &#123;&#123;<span class="string">&quot;JFK&quot;</span>, <span class="string">&quot;KUL&quot;</span>&#125;, &#123;<span class="string">&quot;JFK&quot;</span>, <span class="string">&quot;NRT&quot;</span>&#125;, &#123;<span class="string">&quot;NRT&quot;</span>, <span class="string">&quot;JFK&quot;</span>&#125;&#125;;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; tickets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            String[] strs = array[i];</span><br><span class="line">            List&lt;String&gt; strings = Arrays.asList(strs);</span><br><span class="line">            tickets.add(strings);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(findItinerary(tickets));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新建一个 HashMap&lt;String, ArrayList&lt;String&gt;&gt; map , key 表示 from , value 表示 to 的 list</span></span><br><span class="line"><span class="comment">     * map 填充完毕后，对 list 进行排序，目的在于保证找到result-size长度的第一个集合就是按字符自然排序的</span></span><br><span class="line"><span class="comment">     * （result的size一定等于tickets.length+1）</span></span><br><span class="line"><span class="comment">     * 接着 DFS + 回溯 ，这里注意，从list中获取一个to时，先判断是否为空串，若不是，加入到tempList中，继续调用dfs方法</span></span><br><span class="line"><span class="comment">     * 若是空串，表明，该 to 已经访问过，直接continue！！！</span></span><br><span class="line"><span class="comment">     * -- 注意，dfs处理完当前string后，一定要将其从空串复原， 且 复原 tempResult ！！！</span></span><br><span class="line"><span class="comment">     * --- 定义全局 Boolean变量，剪枝 的同时，保证全局变量result 只会赋值一次 !!</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tickets</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasFind;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findItinerary2</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> </span>&#123;</span><br><span class="line">        result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        hasFind = <span class="keyword">false</span>;</span><br><span class="line">        HashMap&lt;String, ArrayList&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; ticket : tickets) &#123;</span><br><span class="line">            String from = ticket.get(<span class="number">0</span>);</span><br><span class="line">            String to = ticket.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(from)) &#123;</span><br><span class="line">                map.get(from).add(to);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(to);</span><br><span class="line">                map.put(from, list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对list进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, ArrayList&lt;String&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            ArrayList&lt;String&gt; value = entry.getValue();</span><br><span class="line">            value.sort((x, y) -&gt; x.compareTo(y));</span><br><span class="line">        &#125;</span><br><span class="line">        String from = <span class="string">&quot;JFK&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> targetLength = tickets.size() + <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;String&gt; tempResult = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tempResult.add(from);</span><br><span class="line">        dfs2(tempResult, map, from, targetLength);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(ArrayList&lt;String&gt; tempResult, HashMap&lt;String, ArrayList&lt;String&gt;&gt; map, String</span></span></span><br><span class="line"><span class="function"><span class="params">            from, <span class="keyword">int</span> targetLength)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义全局变量，剪枝 的同时，保证全局变量result 只会赋值一次</span></span><br><span class="line">        <span class="keyword">if</span> (hasFind) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tempResult.size() == targetLength) &#123;</span><br><span class="line">            result = <span class="keyword">new</span> ArrayList&lt;&gt;(tempResult);</span><br><span class="line">            hasFind = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(from)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;String&gt; list = map.get(from);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            String to = list.get(i);</span><br><span class="line">            <span class="keyword">if</span> (to.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 修改为空串，表明 改 string 已经访问过了</span></span><br><span class="line">            list.set(i, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            tempResult.add(to);</span><br><span class="line">            dfs2(tempResult, map, to, targetLength);</span><br><span class="line">            <span class="comment">// 复原 tempResult</span></span><br><span class="line">            tempResult.remove(tempResult.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//注意，dfs处理完当前string后，一定要将其从空串复原！！！</span></span><br><span class="line">            list.set(i, to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******************* 代码优化  *****************************************/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：</span></span><br><span class="line"><span class="comment">     * 1、从起点出发，进行深度优先搜索。</span></span><br><span class="line"><span class="comment">     * 2、每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</span></span><br><span class="line"><span class="comment">     * 3、如果没有可移动的路径，则将所在节点加入到栈中，并返回。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 当我们顺序地考虑该问题时，我们也许很难解决该问题，因为我们无法判断当前节点的哪一个分支是「死胡同」分支。</span></span><br><span class="line"><span class="comment">     * 不妨倒过来思考。我们注意到只有那个入度与出度差为 11 的节点会导致死胡同。而该节点必然是最后一个遍历到的节点。</span></span><br><span class="line"><span class="comment">     * 我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即逆序入栈）。</span></span><br><span class="line"><span class="comment">     * 对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。</span></span><br><span class="line"><span class="comment">     * 而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。</span></span><br><span class="line"><span class="comment">     * 也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支入栈。</span></span><br><span class="line"><span class="comment">     * 这样就能保证我们可以「一笔画」地走完所有边，最终的栈中逆序地保存了「一笔画」的结果。我们只要将栈中的内容反转，即可得到答案。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="comment">//定义一个优先级队列，用来存放to集合</span></span><br><span class="line">    <span class="keyword">static</span> HashMap&lt;String, PriorityQueue&lt;String&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; ticket : tickets) &#123;</span><br><span class="line">            String from = ticket.get(<span class="number">0</span>);</span><br><span class="line">            String to = ticket.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(from)) &#123;</span><br><span class="line">                map.put(from, <span class="keyword">new</span> PriorityQueue&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(from).offer(to);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String from)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (map.containsKey(from) &amp;&amp; !map.get(from).isEmpty()) &#123;</span><br><span class="line">            dfs(map.get(from).poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//头插法</span></span><br><span class="line">        list.add(<span class="number">0</span>, from);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>DFS</category>
        <category>回溯-欧拉路径</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>回溯</tag>
        <tag>图</tag>
        <tag>欧拉路径</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-459-重复的子字符串</title>
    <url>/2020/08/24/LeetCode-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当 s 没有循环节时：</span></span><br><span class="line"><span class="comment">     * 如果 s 中没有循环节，那么 ss 中必然有且只有两个 s，此时从 ss[1] 处开始寻找 s ，必然只能找到第二个，所以此时返回值为 s.size()。</span></span><br><span class="line"><span class="comment">     * ----------------</span></span><br><span class="line"><span class="comment">     * 当 s 有循环节时：</span></span><br><span class="line"><span class="comment">     * 当 s 中有循环节时，设循环节为 r，其长度为 l，那么 ss 中必然可以找出 s.size()/l + 1 个 s 。</span></span><br><span class="line"><span class="comment">     * 因为去掉了第一个 S 的第一个字符 (代码中，(s+s).find(s, 1)， 是从 ss[1] 处开始 find )</span></span><br><span class="line"><span class="comment">     * 所以此时必回找到第二个 s 的起点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String substring = (s + s).substring(<span class="number">1</span>, (s + s).length());</span><br><span class="line">        <span class="keyword">return</span> substring.indexOf(s) != (s.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟</span></span><br><span class="line"><span class="comment">     * 如果匹配，则至少循环两次，所以模板子串的最长长度为 length / 2;</span></span><br><span class="line"><span class="comment">     * 从 length / 2 遍历到 1；如果不能被 length 整除，则直接continue，否则遍历N的次数，stringbuilder append 去判断是否相等</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> count = length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = count; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (length % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (deal(s, i)) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">deal</span><span class="params">(String s, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> count = s.length() / length;</span><br><span class="line">        String temp = s.substring(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            sb.append(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.toString().equals(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="模式匹配解法"><a href="#模式匹配解法" class="headerlink" title="模式匹配解法"></a>模式匹配解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>KMP模式匹配</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-491-递增子序列</title>
    <url>/2020/08/25/LeetCode-491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h4 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a href="https://leetcode-cn.com/problems/increasing-subsequences/">491. 递增子序列</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 定义全局变量保存结果</span></span><br><span class="line">        result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// idx 初始化为 -1，开始 dfs 搜索。</span></span><br><span class="line">        dfs(nums, -<span class="number">1</span>, list);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, LinkedList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只要当前的递增序列长度大于 1，就加入到结果 res 中，然后继续搜索递增序列的下一个值。</span></span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList(list));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在 [idx + 1, nums.length - 1] 范围内遍历搜索递增序列的下一个值。</span></span><br><span class="line">        <span class="comment">// 借助 set 对 [idx + 1, nums.length - 1] 范围内的数去重。</span></span><br><span class="line">        <span class="comment">// 注： 表明在当前搜索的范围内，寻找一位符合条件的值，若当前值已经搜索过，则直接continue,否则加入set中，注意哦，set不是dfs的参数</span></span><br><span class="line">        <span class="comment">// 仅仅保存当前搜索范围内的 已搜索情况</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            <span class="comment">// 1. 如果 set 中已经有与 nums[i] 相同的值了，说明加上 nums[i] 后的所有可能的递增序列之前已经被搜过一遍了，因此停止继续搜索。</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(temp)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(temp);</span><br><span class="line">            <span class="comment">// 2. 如果 nums[i] &gt;= list.getLast() 的话，说明出现了新的递增序列，因此继续 dfs 搜索</span></span><br><span class="line">            <span class="comment">// （因为 list 在这里是复用的，因此别忘了 remove 哦）</span></span><br><span class="line">            <span class="keyword">if</span> (list.isEmpty() || list.getLast() &lt;= temp) &#123;</span><br><span class="line">                list.addLast(temp);</span><br><span class="line">                dfs(nums, i, list);</span><br><span class="line">                list.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>DFS</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-51-N皇后</title>
    <url>/2020/09/05/LeetCode-51-N%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<h4 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优化方法 -- check 同一列、主对角线、副对角线的状态检查</span></span><br><span class="line"><span class="comment">     * 主对角线 -- 横坐标 - 纵坐标 （在同一主对角线上的点，两坐标相减总相等 ，为了保证数组不越界，加上偏移量）</span></span><br><span class="line"><span class="comment">     * 副对角线 -- 横坐标 + 纵坐标 （在同一副对角线上的点，两坐标相加总相等）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回溯算法（按行存放 皇后 ，backTracing(help, 0);）</span></span><br><span class="line"><span class="comment">     * backTracing(String[][] help, int index) 当index大于等于n时，结束递归，加入结果集</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 当准备向 第 index 行 选择第 j 列，进行存放 Q 时，先进行竖向检查、左上检查、以及右上检查，都符合条件时，再修改数组，进行递归，</span></span><br><span class="line"><span class="comment">     * 最后 修改回 原先临时数组状态</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] shuXiangHelp;<span class="comment">//j为坐标  size = length  i - j 的取值范围为：[-(length-1) , length -1]</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] zhuDuiJiaoHelp;<span class="comment">// i -j + length -1为坐标  size = 2*length-1;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] fuDuiJiaoHelp;<span class="comment">// i -j + length -1为坐标  size = 2*length-1;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">char</span>[][] help = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        shuXiangHelp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        zhuDuiJiaoHelp = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">        fuDuiJiaoHelp = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">        result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(help[i], <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backTracing(help, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTracing</span><span class="params">(<span class="keyword">char</span>[][] help, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//backTracing(String[][] help, int index) 当index大于等于n时，结束递归，加入结果集</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= help.length) &#123;</span><br><span class="line">            ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">                StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; help[i].length; j++) &#123;</span><br><span class="line">                    builder.append(help[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(builder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当准备向 第 index 行 选择第 j 列，进行存放 Q 时，先进行竖向检查、左上检查、以及右上检查，都符合条件时，再修改数组，进行递归，</span></span><br><span class="line">        <span class="comment">// 最后 修改回 原先临时数组状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; help.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!checkZhuDuiJiao(index, j, help.length)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!checkFuDuiJiao(index, j, help.length)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!checkShuxiang(j)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            zhuDuiJiaoHelp[index - j + help.length - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">            fuDuiJiaoHelp[index + j] = <span class="keyword">true</span>;</span><br><span class="line">            shuXiangHelp[j] = <span class="keyword">true</span>;</span><br><span class="line">            help[index][j] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            backTracing(help, index + <span class="number">1</span>);</span><br><span class="line">            help[index][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            zhuDuiJiaoHelp[index - j + help.length - <span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">            fuDuiJiaoHelp[index + j] = <span class="keyword">false</span>;</span><br><span class="line">            shuXiangHelp[j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主对角线 -- 横坐标 - 纵坐标 （在同一主对角线上的点，两坐标相减总相等 ，为了保证数组不越界，加上偏移量）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkZhuDuiJiao</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> j, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !zhuDuiJiaoHelp[index - j + length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 副对角线 -- 横坐标 + 纵坐标 （在同一副对角线上的点，两坐标相加总相等）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkFuDuiJiao</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> j, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !fuDuiJiaoHelp[index + j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkShuxiang</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !shuXiangHelp[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkXiexiang1</span><span class="params">(<span class="keyword">char</span>[][] help, <span class="keyword">int</span> index, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (help[index - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkXiexiang2</span><span class="params">(<span class="keyword">char</span>[][] help, <span class="keyword">int</span> index, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; j + <span class="number">1</span> &lt; help.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (help[index - <span class="number">1</span>][j + <span class="number">1</span>] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkShuxiang2</span><span class="params">(<span class="keyword">char</span>[][] help, <span class="keyword">int</span> index, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (help[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>DFS</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-486-预测赢家</title>
    <url>/2020/09/05/LeetCode-486-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/</url>
    <content><![CDATA[<h4 id="486-预测赢家"><a href="#486-预测赢家" class="headerlink" title="486. 预测赢家"></a><a href="https://leetcode-cn.com/problems/predict-the-winner/">486. 预测赢家</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归版本 2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = dfs(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> n &gt;= (sum - n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示，先手时，在begin - end 范围内能取的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[begin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin + <span class="number">1</span> == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[begin], nums[end]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前选择begin位置上的数时，则下次选择的范围只能是[begin+1,end-1](后手选择了end)、或者是[bengin+2,end](后手选择了begin+1)</span></span><br><span class="line">        <span class="comment">// Math.min(dfs(nums, begin + 1, end - 1), dfs(nums, begin + 2, end));后手一定会留最小的取值范围</span></span><br><span class="line">        <span class="keyword">int</span> beginValue = nums[begin] + Math.min(dfs(nums, begin + <span class="number">1</span>, end - <span class="number">1</span>), dfs(nums, begin + <span class="number">2</span>, end));</span><br><span class="line">        <span class="keyword">int</span> endValue = nums[end] + Math.min(dfs(nums, begin + <span class="number">1</span>, end - <span class="number">1</span>), dfs(nums, begin, end - <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> Math.max(beginValue, endValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归版本一</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner4</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs2(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, <span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[begin] * flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> socreBegin = nums[begin] * flag + dfs2(nums, begin + <span class="number">1</span>, end, -flag);</span><br><span class="line">        <span class="keyword">int</span> socreEnd = nums[end] * flag + dfs2(nums, begin, end - <span class="number">1</span>, -flag);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(socreBegin, socreEnd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(socreBegin, socreEnd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优化的 DP  -- dp[i][j] 与 另一方法的 表意不同</span></span><br><span class="line"><span class="comment">     * 定义二维数组 dp，其行数和列数都等于数组的长度，dp[i][j] 表示当数组剩下的部分为下标 i 到下标 j时，当前玩家领先数值大小</span></span><br><span class="line"><span class="comment">     * 当前玩家与另一个玩家的分数之差的最大值，注意当前玩家不一定是先手。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 只有当 i≤j 时，数组剩下的部分才有意义，因此当 i&gt;j 时，dp[i][j]=0。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length][length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i][i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">1</span>; end &lt; length; end++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> begin = end - <span class="number">1</span>; begin &gt;= <span class="number">0</span>; begin--) &#123;</span><br><span class="line">                <span class="comment">//begin -end 范围内，player1先手，取begin位置上的数， nums[begin] - dp[begin + 1][end]</span></span><br><span class="line">                <span class="comment">//dp[begin + 1][end] 表示 此时 player2 的领先数值大小</span></span><br><span class="line">                dp[begin][end] = Math.max(nums[begin] - dp[begin + <span class="number">1</span>][end], nums[end] - dp[begin][end - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][length - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dp 动态规划  int[][] dp = new int[length][length];</span></span><br><span class="line"><span class="comment">     * dp[begin][end] 表示: 在nums数组中的begin - end 范围内，先手 所能获取到的最大值</span></span><br><span class="line"><span class="comment">     * 就是计算出player1可能得到的最大分数，然后用数组总和减去player1的得分就是player2的得分，然后两者比较一下就可以了。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner3</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length][length];</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            temp[i] = pre + nums[i];</span><br><span class="line">            pre = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">0</span>; end &lt; length; end++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> begin = end; begin &gt;= <span class="number">0</span>; begin--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前 begin 和 end 相等，则dp[begin][end] = nums[end];</span></span><br><span class="line">                    dp[begin][end] = nums[end];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当前先手取 begin位置上的值，则 num1 = nums[begin] + （begin-1,end）范围内的最小值</span></span><br><span class="line">                    <span class="comment">//（begin-1,end）范围内的最小值 的获取： sum(begin + 1, end, nums) - dp[begin + 1][end];</span></span><br><span class="line">                    <span class="comment">//（begin-1,end）所有数据之和  减去 （begin-1,end）范围内先手的最大值</span></span><br><span class="line">                    <span class="keyword">int</span> num1 = nums[begin] + sum(begin + <span class="number">1</span>, end, nums) - dp[begin + <span class="number">1</span>][end];</span><br><span class="line">                    <span class="comment">//当前先手取 end 位置上的值</span></span><br><span class="line">                    <span class="keyword">int</span> num2 = nums[end] + sum(begin, end - <span class="number">1</span>, nums) - dp[begin][end - <span class="number">1</span>];</span><br><span class="line">                    dp[begin][end] = Math.max(num1, num2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = sum(<span class="number">0</span>, length - <span class="number">1</span>, nums);</span><br><span class="line">        <span class="keyword">int</span> leftNum = sum - dp[<span class="number">0</span>][length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][length - <span class="number">1</span>] &gt;= leftNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求取begin - end 之间的和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> temp[end] - temp[begin] + nums[begin];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-5495-圆形赛道上经过次数最多的扇区</title>
    <url>/2020/08/23/LeetCode-5495-%E5%9C%86%E5%BD%A2%E8%B5%9B%E9%81%93%E4%B8%8A%E7%BB%8F%E8%BF%87%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E6%89%87%E5%8C%BA/</url>
    <content><![CDATA[<h4 id="5495-圆形赛道上经过次数最多的扇区"><a href="#5495-圆形赛道上经过次数最多的扇区" class="headerlink" title="5495. 圆形赛道上经过次数最多的扇区"></a><a href="https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track/">5495. 圆形赛道上经过次数最多的扇区</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、使用N的数组保存，模拟计数</span></span><br><span class="line"><span class="comment">     * 2、简化问题：</span></span><br><span class="line"><span class="comment">     * （1）当数组的第一位 和 最后一位是相同的，则表明，中间跑了完整的 M 圈，</span></span><br><span class="line"><span class="comment">     * 由于是起始位置，那么就会相对于其他分段 就会多跑一次，所以返回起始阶段</span></span><br><span class="line"><span class="comment">     * （2）如果，起始点和结束点不一致，则分为两种情况，结束点 大于 起始点，则直接保存即可</span></span><br><span class="line"><span class="comment">     * 结束点 小于 起始点，表明跨越了最大分段，需要再从1加到结束点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rounds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">mostVisited</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] rounds)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> begin = rounds[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> end = rounds[rounds.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            result.add(begin);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (begin != end) &#123;</span><br><span class="line">                result.add(begin);</span><br><span class="line">                begin++;</span><br><span class="line">                <span class="keyword">if</span> (begin &gt; n) &#123;</span><br><span class="line">                    begin -= n;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(end);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-5496-你可以获得的最大硬币数目</title>
    <url>/2020/08/23/LeetCode-5496-%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%A1%AC%E5%B8%81%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h4 id="5496-你可以获得的最大硬币数目"><a href="#5496-你可以获得的最大硬币数目" class="headerlink" title="5496. 你可以获得的最大硬币数目"></a><a href="https://leetcode-cn.com/problems/maximum-number-of-coins-you-can-get/">5496. 你可以获得的最大硬币数目</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 你可以获得的最大硬币数目<span class="title">_5496</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 贪心算法</span></span><br><span class="line"><span class="comment">     * 先排序，再将当前最小的和最大的分给其他两人，自己保留次大的数，排除当前三个数后再依次执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> piles</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] piles)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(piles);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = piles.length / <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//简化版： 先将最小的 N/3 个分出去，再从0开始第(N/3)个遍历累加，每次index+=2;</span></span><br><span class="line">        <span class="keyword">for</span> (; begin &lt; piles.length; begin += <span class="number">2</span>) &#123;</span><br><span class="line">            result += piles[begin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-5497-查找大小为M的最新分组</title>
    <url>/2020/08/23/LeetCode-5497-%E6%9F%A5%E6%89%BE%E5%A4%A7%E5%B0%8F%E4%B8%BAM%E7%9A%84%E6%9C%80%E6%96%B0%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h4 id="5497-查找大小为-M-的最新分组"><a href="#5497-查找大小为-M-的最新分组" class="headerlink" title="5497. 查找大小为 M 的最新分组"></a><a href="https://leetcode-cn.com/problems/find-latest-group-of-size-m/">5497. 查找大小为 M 的最新分组</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 查找大小为<span class="title">M</span>的最新分组<span class="title">_5497</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并查集 -- 使用两个数组，一个保存当前节点的父节点，另一个用来保存集合父节点所在集合的总的个数</span></span><br><span class="line"><span class="comment">     * 之后就是遍历数组，每个节点都要判断 左右节点的情况，一共四种</span></span><br><span class="line"><span class="comment">     * 使用int count 计数，符合 m 的个数的集合 一种的个数，处理当前节点时，判断count 是否为0</span></span><br><span class="line"><span class="comment">     * 不为0，则表明当前步骤有有效步骤，赋值给 result;否则，当前步骤无效，不做记录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLatestStep</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//数组的范围 取值为 0-1--n-n+1,为了防止数组越界，其中0 和 n+1 防止数组越界</span></span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">2</span>];</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = arr[i - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//如果，当前位置的左右两个数都为0 (不会对当前的数字情况造成任何影响)</span></span><br><span class="line">            <span class="keyword">if</span> (parent[index - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; parent[index + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                parent[index] = index;</span><br><span class="line">                nums[index] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[index] == m) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前位置的 左边不为 0 ，右边为 0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (parent[index - <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; parent[index + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//注意合并集的时候，往右合并（较大值）--这样 左边的数 就无需递归寻找父节点</span></span><br><span class="line">                parent[index - <span class="number">1</span>] = index;</span><br><span class="line">                parent[index] = index;</span><br><span class="line">                nums[index] = <span class="number">1</span> + nums[index - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> (nums[index - <span class="number">1</span>] == m) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[index] == m) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前位置的 左边为 0 ，右边不为 0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (parent[index - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; parent[index + <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> parentNode = findParent(index + <span class="number">1</span>);</span><br><span class="line">                parent[index] = parentNode;</span><br><span class="line">                <span class="keyword">if</span> (nums[parentNode] == m) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[parentNode] = <span class="number">1</span> + nums[parentNode];</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> (nums[parentNode] == m) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前位置的 左边 和 右边 都不为 0</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> parentNode = findParent(index + <span class="number">1</span>);</span><br><span class="line">                parent[index] = parentNode;</span><br><span class="line">                parent[index - <span class="number">1</span>] = parentNode;</span><br><span class="line">                <span class="keyword">if</span> (nums[parentNode] == m) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[index - <span class="number">1</span>] == m) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[parentNode] = <span class="number">1</span> + nums[parentNode] + nums[index - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nums[parentNode] == m) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前节点处理完毕，判断count，不为0，则表明当前步骤有有效步骤，赋值给 result;</span></span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">                result = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归寻找父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findParent</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">            <span class="keyword">return</span> findParent(parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>使用hexo + github page搭建个人博客</title>
    <url>/2020/08/22/%E4%BD%BF%E7%94%A8hexo-github-page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>首先下载稳定版<a href="https://nodejs.org/dist/v9.11.1/node-v9.11.1-x64.msi">Node.js</a>，我这里给的是64位的。</p>
<p>安装选项全部默认，一路点击<code>Next</code>。</p>
<p>最后安装好之后，按<code>Win+R</code>打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p>
<h1 id="添加国内镜像源"><a href="#添加国内镜像源" class="headerlink" title="添加国内镜像源"></a>添加国内镜像源</h1><p>如果没有梯子的话，可以使用阿里的国内镜像进行加速。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><p>为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具————Git[<a href="https://git-scm.com/download/win">下载地址]</a>。</p>
<p>安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了。</p>
<p>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功。</p>
<a id="more"></a>

<h1 id="注册Github账号"><a href="#注册Github账号" class="headerlink" title="注册Github账号"></a>注册Github账号</h1><p>接下来就去注册一个github账号，用来存放我们的网站。大多数小伙伴应该都有了吧，作为一个合格的程序猿（媛）还是要有一个的。</p>
<p>打开<a href="https://github.com/%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%EF%BC%9A">https://github.com/，新建一个项目，如下所示：</a></p>
<p>然后如下图所示，输入自己的项目名字，后面一定要加<code>.github.io</code>后缀，README初始化也要勾上。<strong>名称一定要和你的github名字完全一样，比如你github名字叫<code>abc</code>，那么仓库名字一定要是<code>abc.github.io</code>。</strong></p>
<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在<code>D:\study\program\blog</code>目录下。</p>
<p>在该目录下右键点击<code>Git Bash Here</code>，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。</p>
<p>定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，无视它就行。</p>
<p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p>
<p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p>
<p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<a href="http://localhost:4000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%88%91%E4%BB%AC%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%95%A6%EF%BC%8C%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:4000/，就可以看到我们的博客啦，效果如下：</a></p>
<h1 id="安装Hexo-1"><a href="#安装Hexo-1" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在<code>D:\study\program\blog</code>目录下。</p>
<p>在该目录下右键点击<code>Git Bash Here</code>，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。</p>
<p>定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，无视它就行。</p>
<p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p>
<p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p>
<p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<a href="http://localhost:4000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%88%91%E4%BB%AC%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%95%A6%EF%BC%8C%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:4000/，就可以看到我们的博客啦，效果如下：</a></p>
<p><img src="/2020/08/22/%E4%BD%BF%E7%94%A8hexo-github-page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/WorkSpace\blog\source_posts\5.jpg" alt="img"></p>
<h1 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h1><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code>。</p>
<p>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p>
<p>然后打开<code>D:\study\program\blog\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p>
<p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p>
<h1 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h1><p>现在默认的域名还是<code>xxx.github.io</code>，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。</p>
<p>以我的百度云为例，如下图所示，添加两条解析记录：</p>
<p>然后打开你的github博客项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存：</p>
<p>这时候你的项目根目录应该会出现一个名为<code>CNAME</code>的文件了。如果没有的话，打开你本地博客<code>/source</code>目录，我的是<code>D:\study\program\blog\source</code>，新建<code>CNAME</code>文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行<code>hexo g</code>、<code>hexo d</code>上传到github。</p>
<h1 id="备份博客源文件"><a href="#备份博客源文件" class="headerlink" title="备份博客源文件"></a>备份博客源文件</h1><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。</p>
<p>首先在github博客仓库下新建一个分支<code>hexo</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下。</p>
<p>然后<code>git checkout hexo</code>切换到<code>hexo</code>分支，然后<code>git add .</code>，然后<code>git commit -m &quot;xxx&quot;</code>，最后<code>git push origin hexo</code>提交就行了。</p>
<p>当然我新建了一个仓库存放了源文件，具体效果可以看我的博客源文件仓库：<a href="https://github.com/godweiyang/hexo-matery-modified%E3%80%82%E5%A4%A7%E5%AE%B6%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%85%88%E7%94%A8%E4%B8%8B%E6%96%87hexo%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E5%AE%89%E8%A3%85%E5%AE%8Chexo%EF%BC%8C%E7%84%B6%E5%90%8E%E7%9B%B4%E6%8E%A5%60git">https://github.com/godweiyang/hexo-matery-modified。大家也可以先用下文hexo安装方法安装完hexo，然后直接`git</a> clone <a href="mailto:&#103;&#105;&#x74;&#64;&#103;&#105;&#116;&#x68;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#105;&#x74;&#64;&#103;&#105;&#116;&#x68;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;</a>:godweiyang/hexo-matery-modified.git`克隆我的所有源文件，然后这是我修改完的基本没bug的定制化的博客，就可以直接拿来用啦。</p>
<p><strong>我这个源文件和原来的主题没有什么区别，只是我把插件都安装完了，有些小bug也修复了，所以拿来就能直接用，方便大家。</strong></p>
<h1 id="博客源代码下载"><a href="#博客源代码下载" class="headerlink" title="博客源代码下载"></a>博客源代码下载</h1><p>如果大家不想这么麻烦的装一堆东西，然后还要自己修改bug，那么只需要做好上面的准备工作，然后下载我的源代码，改改个人配置就行了。</p>
<p>源码地址：<a href="https://github.com/godweiyang/hexo-matery-modified%E3%80%82%E5%A4%A7%E5%AE%B6%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E4%B8%8B%E6%9D%A5%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%BF%AE%E6%94%B9%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E5%8D%B3%E5%8F%AF%EF%BC%8C%E5%BD%93%E7%84%B6%E7%8E%AF%E5%A2%83%E8%A6%81%E5%85%88%E6%90%AD%E5%A5%BD%E3%80%82">https://github.com/godweiyang/hexo-matery-modified。大家可以直接下载下来使用，修改个人配置信息即可，当然环境要先搭好。</a></p>
<p><strong>如果大家下载好了源代码，就可以直接使用了，基本可以跳过文章后面的部分了！喜欢的记得star并fork哦！</strong></p>
<h1 id="个性化设置（matery主题）"><a href="#个性化设置（matery主题）" class="headerlink" title="个性化设置（matery主题）"></a>个性化设置（matery主题）</h1><p>下面的个性化设置主要针对的是<code>matery</code>主题，如果你想用我现在博客这个主题，可以直接看这个章节。</p>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>这两天花时间将我的博客换了一个主题，现在这个主题看着更加的炫（zhuang）酷（bi），并且响应式更友好，点起来就很舒服，功能也多很多。</p>
<p>主题的原地址在这里：<a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a>，它的文档写得也非常的详细，还有中英文两个版本，作者回复也很及时。效果图如下，可以看出非常合我的口味：</p>
<h2 id="文章开启阅读更多按钮"><a href="#文章开启阅读更多按钮" class="headerlink" title="文章开启阅读更多按钮"></a>文章开启阅读更多按钮</h2><p>如果不开启阅读更多按钮的话，默认是展示文章中所有内容的，这显然体验不好。</p>
<p>一般都会在文章中插入<code>&lt;!--more--&gt;</code>这种注释形式表示首页展示到注释处为止。</p>
<h2 id="新建左侧分类栏"><a href="#新建左侧分类栏" class="headerlink" title="新建左侧分类栏"></a>新建左侧分类栏</h2><p>修改 theme中的配置，如</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="attr">LeetCode:</span> <span class="string">/LeetCode/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-code</span></span><br><span class="line">  <span class="attr">Java:</span> <span class="string">/Java/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-backward</span></span><br><span class="line">  <span class="string">后端:</span> <span class="string">/后端/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">DataBase:</span> <span class="string">/DataBase/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-database</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">/sitemap.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>

<p>操作命令行</p>
<p> hexo new page “LeetCode”</p>
<p>修改source文件夹中对应的index.md文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2020-08-22 22:35:39</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure>

<p>修改blog\scaffolds 下的默认md文件头信息</p>
]]></content>
      <tags>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title>后端-Java虚拟机-ClassLoader类加载机制</title>
    <url>/2020/09/14/%E5%90%8E%E7%AB%AF-Java%E8%99%9A%E6%8B%9F%E6%9C%BA-ClassLoader%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="ClassLoader类加载机制"><a href="#ClassLoader类加载机制" class="headerlink" title="ClassLoader类加载机制"></a>ClassLoader类加载机制</h1><h2 id="类加载器的命名空间"><a href="#类加载器的命名空间" class="headerlink" title="类加载器的命名空间"></a>类加载器的命名空间</h2><p>类加载器的命名空间-是由类加载器本身及其所有父加载器所加载出来的binary name（full class name 组成）<br>1、在同一个命名空间里，不允许出现两个完全一样的binary name<br>2、在不同的命名空间中，可以出现两个相同的binary name,但是两者对应的class 对象是相互不能感知到的，也就是class对象的类型是不一样的<br>3、子加载器的命名空间中的binary name对应的类中可以访问 父加载器命名空间中的binary name对应的类，反之则不行</p>
<a id="more"></a>

<h2 id="类加载机制：全盘负责和双亲委托"><a href="#类加载机制：全盘负责和双亲委托" class="headerlink" title="类加载机制：全盘负责和双亲委托"></a>类加载机制：全盘负责和双亲委托</h2><p>“全盘负责”是指当一个ClassLoader装载一个类时，除非显示地使用另一个ClassLoader，则该类所依赖及引用的类也由这个CladdLoader载入。</p>
<p>例如，系统类加载器AppClassLoader加载入口类（含有main方法的类）时，会把main方法所依赖的类及引用的类也载入，依此类推。“全盘负责”机制也可称为当前类加载器负责机制。显然，入口类所依赖的类及引用的类的当前类加载器就是入口类的类加载器。</p>
<p>以上步骤只是调用了ClassLoader.loadClass(name)方法，并没有真正定义类。真正加载class字节码文件生成Class对象由“双亲委派”机制完成。</p>
<p>“双亲委派”是指子类加载器如果没有加载过该目标类，就先委托父类加载器加载该目标类，只有在父类加载器找不到字节码文件的情况下才从自己的类路径中查找并装载目标类。</p>
<p>“双亲委派”机制加载Class的具体过程是：</p>
<ol>
<li><p>源ClassLoader先判断该Class是否已加载，如果已加载，则返回Class对象；如果没有则委托给父类加载器。</p>
</li>
<li><p>父类加载器判断是否加载过该Class，如果已加载，则返回Class对象；如果没有则委托给祖父类加载器。</p>
</li>
<li><p>依此类推，直到始祖类加载器（引用类加载器）。</p>
</li>
<li><p>始祖类加载器判断是否加载过该Class，如果已加载，则返回Class对象；如果没有则尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的子类加载器。</p>
</li>
<li><p>始祖类加载器的子类加载器尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的孙类加载器。</p>
</li>
<li><p>依此类推，直到源ClassLoader。</p>
</li>
<li><p>源ClassLoader尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，源ClassLoader不会再委托其子类加载器，而是抛出异常。</p>
</li>
</ol>
<p>“双亲委派”机制只是<a href="http://lib.csdn.net/base/java">Java</a>推荐的机制，并不是强制的机制。</p>
<p>我们可以继承java.lang.ClassLoader类，实现自己的类加载器。如果想保持双亲委派模型，就应该重写findClass(name)方法；如果想破坏双亲委派模型，可以重写loadClass(name)方法。</p>
<h2 id="双亲委派的好处-及-如何打破"><a href="#双亲委派的好处-及-如何打破" class="headerlink" title="双亲委派的好处 及 如何打破"></a>双亲委派的好处 及 如何打破</h2><p>加载器自上而下分别为，<strong>启动类加载器(Bootstrap ClassLoader), 拓展类加载器(Extension ClassLoader), 系统类加载器(Application ClassLoader) ,</strong> 自定义类加载器(Custom ClassLoader)</p>
<p>其工作原理是，如果其中一个类加载器收到了类加载的请求，它并不会自己去加载而是会将该请求委托给父类的加载器去执行，如果父类加载器还存在父类加载器，则进一步向上委托，如此递归，请求最终到达顶层的启动类加载器。如果父类能加载，则直接返回，如果父类加载不了则交由子类加载，这就是双亲委派模式。</p>
<p><img src="https://img-blog.csdnimg.cn/20200404144426738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2IxMzAzMTEwMzM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>双亲委派模型有两个好处：</p>
<ol>
<li>向上委托给父类加载，父类加载不了再自己加载</li>
<li>避免重复加载，防止Java核心api被篡改</li>
</ol>
<h3 id="如何打破双亲委派模型？"><a href="#如何打破双亲委派模型？" class="headerlink" title="如何打破双亲委派模型？"></a><strong>如何打破双亲委派模型？</strong></h3><ol>
<li>自定义类加载器，重写loadClass方法；</li>
<li>使用线程上下文类加载器；</li>
</ol>
<h2 id="双亲委派模型破坏史"><a href="#双亲委派模型破坏史" class="headerlink" title="双亲委派模型破坏史"></a><strong>双亲委派模型破坏史</strong></h2><p>1.第一次破坏</p>
<p>由于双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。在此之前，用户去继承java.lang.ClassLoader的唯一目的就是为了重写loadClass()方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法唯一逻辑就是去调用自己的loadClass()。</p>
<p>2.第二次破坏</p>
<p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的同一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美。</p>
<p>如果基础类又要调用回用户的代码，那该么办？</p>
<p>一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，<br>它的代码由启动类加载器去加载（在JDK1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码，但启动类加载器不可能“认识”这些代码。</p>
<p>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p>有了线程上下文加载器，JNDI服务就可以使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、<strong>JDBC</strong>、JCE、JAXB和JBI等。</p>
<p>3.第三次破坏</p>
<p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。<br>OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当受到类加载请求时，OSGi将按照下面的顺序进行类搜索：<br>1）将java.＊开头的类委派给父类加载器加载。<br>2）否则，将委派列表名单内的类委派给父类加载器加载。<br>3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。<br>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。<br>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。<br>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。<br>7）否则，类加载器失败。</p>
<h2 id="聊聊JDBC是如何破坏双亲委派模型的"><a href="#聊聊JDBC是如何破坏双亲委派模型的" class="headerlink" title="聊聊JDBC是如何破坏双亲委派模型的"></a>聊聊JDBC是如何破坏双亲委派模型的</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (1)注册驱动</span></span><br><span class="line">     Class.forName(name);</span><br><span class="line"><span class="comment">//(2) 获取链接</span></span><br><span class="line">     conn = DriverManager.getConnection(url, user, password);</span><br></pre></td></tr></table></figure>

<p><strong>Class.forName(name); ：尝试加载MySQL厂商的Driver驱动，此时执行该类的静态代码块，该代码块中，执行DriverManager的regist静态方法，此时又会触发classloader加载DriverManager，rt.jar中的DriverManager加载时，执行静态代码块，使用SPI的方式来加载jdbc驱动,首先从线程上下文类加载器Thread.currentThread().getContextClassLoader()中获取系统类加载器applicationClassLoader,并使用该类加载器去加载各自厂商实现的Driver</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//权限校验</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDriverAllowed</span><span class="params">(Driver driver, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(driver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            aClass =  Class.forName(driver.getClass().getName(), <span class="keyword">true</span>, classLoader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         result = ( aClass == driver.getClass() ) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用callerCL类加载器去加载driver，然后判断当前加载的Class和driver的Class是否是同一个对象，是则成功，否者失败。这里注册Driver时候类加载器为BootStrap,而callerCL是AppClassloader，由于委托机制，所以这里返回true.也就是注册驱动时候类加载器和使用时候必须是同一个或者具有委托关系时候才会鉴权成功，也就是说才有权限去调用驱动的connect方法。</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>Java虚拟机</category>
        <category>虚拟机类加载机制</category>
      </categories>
      <tags>
        <tag>类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配算法-KMP</title>
    <url>/2020/08/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95-KMP/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * * 第一步，求最大公共前后缀的长度</span></span><br><span class="line"><span class="comment"> * * 根据原始字符串新建一个等长的辅助数组 prefix，存储从第 0 位 开始 到 第 i 位的 parten 的最大公共前后缀 的长度</span></span><br><span class="line"><span class="comment"> * * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * * 0 --  AB</span></span><br><span class="line"><span class="comment"> * * 0 --  ABC</span></span><br><span class="line"><span class="comment"> * * 0 --  ABCD</span></span><br><span class="line"><span class="comment"> * * 1 --  ABCDA</span></span><br><span class="line"><span class="comment"> * * 2 -- ABCDAB</span></span><br><span class="line"><span class="comment"> * * 3 -- ABCDABC</span></span><br><span class="line"><span class="comment"> * * 1 -- ABCDABCA</span></span><br><span class="line"><span class="comment"> * * 最终 prefix数组为 [0, 0, 0, 0, 1, 2, 3, 1]</span></span><br><span class="line"><span class="comment"> * * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * * 第二步：开始匹配</span></span><br><span class="line"><span class="comment"> * * 当text[i] == parten[j]相等时，i++，j++,两个指针都右移</span></span><br><span class="line"><span class="comment"> * * 不相等时；j = prefix[j]; 若j==-1，说明已经到头，i++,j++</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parten</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">kmpSearch</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">char</span>[] parten)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> partenLength = parten.length;</span><br><span class="line">    <span class="keyword">int</span> textLength = text.length;</span><br><span class="line">    <span class="keyword">int</span>[] prefix = <span class="keyword">new</span> <span class="keyword">int</span>[partenLength];</span><br><span class="line">    <span class="comment">//第一步：填充prefixs数组</span></span><br><span class="line">    prefixTable(parten, prefix);</span><br><span class="line">    <span class="comment">//第二步：移动prefixs数组</span></span><br><span class="line">    move_prefix_table(prefix);</span><br><span class="line">    <span class="comment">//双指针 ； i 指向 text的下标 -- j指向 parten的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; textLength) &#123;</span><br><span class="line">        <span class="comment">// 当模式串的前partenLength - 1 都匹配，且 text当前位 等于 模式串的最后一位时，匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (j == partenLength - <span class="number">1</span> &amp;&amp; text[i] == parten[j]) &#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            result = i - partenLength + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当text[i] == parten[j]相等时，i++，j++,两个指针都右移</span></span><br><span class="line">        <span class="keyword">if</span> (text[i] == parten[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = prefix[j];</span><br><span class="line">            <span class="comment">//已经到头了，也都不相等, i++</span></span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 整体往右移动prefix数组，在第0位补为 -1；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prefix</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move_prefix_table</span><span class="params">(<span class="keyword">int</span>[] prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prefix.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        prefix[i] = prefix[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    prefix[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用双指针 j 和 i,初始化 j = 0 , i =1;</span></span><br><span class="line"><span class="comment"> * 遍历 i 到最后一位，i指明的是 当前处理的是 parten 的 第 i 位，且需要求出当前 公共前后缀数组的 第 i 位的值；</span></span><br><span class="line"><span class="comment"> * prefix[i]表示的意思是: 从第 0 位 开始 到 第 i 位的 parten 的最大公共前后缀 的长度</span></span><br><span class="line"><span class="comment"> * 初始默认 prefix[0] = 0;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parten</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prefixTable</span><span class="params">(<span class="keyword">char</span>[] parten, <span class="keyword">int</span>[] prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = parten.length;</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">        <span class="comment">// 当 parten[i] == parten[j] 时，则 prefix[i] = j + 1;</span></span><br><span class="line">        <span class="keyword">if</span> (parten[i] == parten[j]) &#123;</span><br><span class="line">            prefix[i] = j + <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果 j == 0 ,则表明 已经到达头部节点 且 与 i 位置的数不相等，则可以直接将 prefix[i] 置为 0;</span></span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                prefix[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = prefix[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>字符串匹配算法</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>字符串匹配算法</tag>
      </tags>
  </entry>
  <entry>
    <title>后端-Java虚拟机-运行时栈帧结构</title>
    <url>/2020/09/14/%E5%90%8E%E7%AB%AF-Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a><a href="https://www.cnblogs.com/wade-luffy/p/6058067.html">运行时栈帧结构</a></h1><p><strong>目录</strong></p>
<ul>
<li><p>局部变量表</p>
</li>
<li><p>操作数栈</p>
</li>
<li><p>动态连接</p>
</li>
<li><p>方法返回地址</p>
</li>
<li><p>附加信息</p>
<a id="more"></a>

</li>
</ul>
<p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。每一个栈帧都包括了<strong>局部变量表、操作数栈、动态连接、方法返回地址</strong>和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p>
<p>一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与这个栈帧相关联的方法称为当前方法（Current Method）。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图所示。</p>
<p><img src="/2020/09/14/%E5%90%8E%E7%AB%AF-Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/1.jpg" alt="img"></p>
<h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。</p>
<h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出（Last In First Out,LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</p>
<p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。举个例子，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。</p>
<h2 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h2><p><strong><em>动态链接的含义–（找到目标调用方法在常量池中的位置引用）</em></strong><br><strong><em>栈帧中保存了一个引用，相当于C语言中的指针，指向该方法在运行时常量池中的位置。通过运行时常量池的符号引用（指向堆），完成将符号引用转化为直接引用。</em></strong></p>
<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。我们知道Class文件的常量池中存有大量的符号引用，<strong>字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。（静态分派，动态分派）</strong></p>
<h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>当一个方法开始执行后，只有两种方式可以退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。</p>
<p>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。</p>
<p>无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p>
<p>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>Java虚拟机</category>
        <category>Java内存区域与内存溢出</category>
      </categories>
      <tags>
        <tag>栈帧结构</tag>
      </tags>
  </entry>
  <entry>
    <title>后端-分布式事务-漫话分布式系统共识协议: 2PC/3PC篇</title>
    <url>/2020/09/05/%E5%90%8E%E7%AB%AF-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%BC%AB%E8%AF%9D%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE-2PC-3PC%E7%AF%87/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>后端</category>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
</search>
